// Auto-generated by generate-example-docs.mjs - do not edit
import React from 'react';
import ManimExample from '../ManimExample';

async function animate(scene: any) {
  const { ThreeDAxes, Group, RED_D, RED_E } = await import('manim-web');
  const { BufferAttribute, Color, FrontSide, Mesh, MeshLambertMaterial, SphereGeometry } =
    await import('three');

  const axes = new ThreeDAxes({
    xRange: [-5, 5, 1],
    yRange: [-5, 5, 1],
    zRange: [-5, 5, 1],
    xLength: 10,
    yLength: 10,
    zLength: 10,
    axisColor: '#ffffff',
    tipLength: 0.2,
    tipRadius: 0.08,
    shaftRadius: 0.01,
  });

  // Checkerboard sphere using SphereGeometry for proper topology
  // (no pole/seam artifacts that ParametricGeometry can produce)
  const widthSegs = 32;
  const heightSegs = 16;
  const geom = new SphereGeometry(1.5, widthSegs, heightSegs);
  // Convert to non-indexed for per-face checkerboard vertex colors
  const nonIndexed = geom.toNonIndexed();
  geom.dispose();

  const posAttr = nonIndexed.getAttribute('position');
  const colors = new Float32Array(posAttr.count * 3);
  const c1 = new Color(RED_D);
  const c2 = new Color(RED_E);

  // SphereGeometry: each quad = 2 triangles = 6 verts, except poles = 1 triangle = 3 verts
  // Layout: top cap (widthSegs triangles), then (heightSegs-2) rows of quads, then bottom cap
  let vi = 0;
  // Top cap: widthSegs triangles
  for (let i = 0; i < widthSegs; i++) {
    const c = i % 2 === 0 ? c1 : c2;
    for (let k = 0; k < 3; k++) {
      colors[vi * 3] = c.r;
      colors[vi * 3 + 1] = c.g;
      colors[vi * 3 + 2] = c.b;
      vi++;
    }
  }
  // Middle rows: (heightSegs - 2) rows × widthSegs quads × 6 verts
  for (let row = 0; row < heightSegs - 2; row++) {
    for (let col = 0; col < widthSegs; col++) {
      const c = (row + col) % 2 === 0 ? c1 : c2;
      for (let k = 0; k < 6; k++) {
        colors[vi * 3] = c.r;
        colors[vi * 3 + 1] = c.g;
        colors[vi * 3 + 2] = c.b;
        vi++;
      }
    }
  }
  // Bottom cap: widthSegs triangles
  for (let i = 0; i < widthSegs; i++) {
    const c = (i + (heightSegs - 2)) % 2 === 0 ? c1 : c2;
    for (let k = 0; k < 3; k++) {
      colors[vi * 3] = c.r;
      colors[vi * 3 + 1] = c.g;
      colors[vi * 3 + 2] = c.b;
      vi++;
    }
  }
  nonIndexed.setAttribute('color', new BufferAttribute(colors, 3));

  const mat = new MeshLambertMaterial({
    vertexColors: true,
    side: FrontSide,
    emissive: new Color('#883333'),
    emissiveIntensity: 1.0,
  });
  const sphereMesh = new Mesh(nonIndexed, mat);

  // Wrap in Group so scene.add() works
  const sphere = new Group();
  sphere.getThreeObject().add(sphereMesh);

  // Multi-directional lighting to eliminate dark shadows (matches Python Manim)
  scene.lighting.removeAll();
  scene.lighting.addAmbient({ intensity: 3.0 });
  scene.lighting.addDirectional({ position: [0, 5, 3], intensity: 1.5 });
  scene.lighting.addDirectional({ position: [0, -3, -3], intensity: 1.0 });
  scene.lighting.addDirectional({ position: [-5, 0, 0], intensity: 0.5 });

  scene.add(axes);
  scene.add(sphere);

  // Re-enable depth testing for the 3D sphere mesh.
  // Scene.add() disables depthTest (correct for 2D), but this raw Mesh
  // needs it for proper 3D occlusion.
  mat.depthTest = true;
  mat.depthWrite = true;

  await scene.wait();
}

function createScene(container: HTMLElement, manim: any) {
  return new manim.ThreeDScene(container, {
    width: 800,
    height: 450,
    backgroundColor: '#000000',
    phi: 75 * (Math.PI / 180),
    theta: 30 * (Math.PI / 180),
    distance: 20,
    fov: 30,
  });
}

export default function ThreeDLightSourcePositionExample() {
  return <ManimExample animationFn={animate} createScene={createScene} />;
}
